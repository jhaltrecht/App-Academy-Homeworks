q
@store.delete(node.key)
c
s
q
node.val
s
bucket(key).include?(key)
s
c
n
node.val
n
s
c
s
node.val
node.key
node
node.val
node.key
node.val
s
node.val 
s
bucket(key).get(key)
bucket(key)
s
q
n
s
q
@map[key]
q
nn
n
s
q
@store
bucket
s
self
s
n
s
c
q
@tail
next_node
next_node==@tail
s
@head.next
@tail
self
@tail
@head.next==@tail
@head.next
s
@store.empty? 
n
q
self
next_node
next_node==@tail
s
n
s
c
q
self
@head
@tail.prev
next_node
next_node==@tail
s
@store.empty? 
n
s
n
s
@store.empty?
q
c
q
c
n
s
next_node==@tail
s
q
next_node
next_node==@tail
s
@store
q
@store
n
next_node==@tail
s
!@store.empty? 
q
n
q
c
q
next_node==@tail
s
@store
@store.empty? 
q
n
q
n
s
q
cq
c
q
s
n
q
n
val
n
max
count
n
@map[key]=@store.append(key,val)
n
s
n
q
n
s
val=@prc.call(key)
s
q
@map[key]
q
c
q
next_node==@tail
s
@map[key]
q
@tail
next_node
s
@map[key]
q
c
q
c
s
@map[key]
map[key]
q
c
q
c
q
key
@map[key]
c
s
key
s
@map[key]
q
@map[key]
map[key]
q
@map
@map.key
q
@map
q
s
c
s
next_node==@tail
s
node
s
bucket
s
c
n
s
@map
c
q
goal
result.sort
result
goal
result.sort
n
s
c
q
[k,v]
result << [k, v]
goal
s
q
n
s
n
s
result
s
q
result
s
result.sort
result
s
n
s
c
q
y
q
s
yield node
s
next_node==@tail
s
next_node=@head.next
s
q
qy
node
q
c
s
q
next_node
next_node==@tail
s
node
s
node
s
bucket
s
@store.each
@store
q
c
s
next_node==@tail
until next_node==@tail
s
q
